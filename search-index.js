var searchIndex = {};
searchIndex["carboxyl"] = {"doc":"*Carboxyl* provides primitives for functional reactive programming in Rust. It draws inspiration from the [Sodium][sodium] libraries and Push-Pull FRP, as described by [Elliott (2009)][elliott_push_pull].","items":[[3,"Sink","carboxyl","An event sink.",null,null],[3,"Stream","","A stream of events.",null,null],[3,"Signal","","A continuous signal that changes over time.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"sink"}}],[11,"new","","Create a new sink.",0,{"inputs":[],"output":{"name":"sink"}}],[11,"stream","","Generate a stream that fires all events sent into the sink.",0,{"inputs":[{"name":"self"}],"output":{"name":"stream"}}],[11,"send_async","","Asynchronous send.",0,{"inputs":[{"name":"self"},{"name":"a"}],"output":null}],[11,"feed","","Feed values from an iterator into the sink.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"feed_async","","Asynchronous feed.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"send","","Send a value into the sink.",0,{"inputs":[{"name":"self"},{"name":"a"}],"output":null}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"stream"}}],[11,"never","","Create a stream that never fires. This can be useful in certain situations, where a stream is logically required, but no events are expected.",1,{"inputs":[],"output":{"name":"stream"}}],[11,"map","","Map the stream to another stream using a function.",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"stream"}}],[11,"filter","","Filter a stream according to a predicate.",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"stream"}}],[11,"filter_map","","Both filter and map a stream.",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"stream"}}],[11,"merge","","Merge with another stream.",1,{"inputs":[{"name":"self"},{"name":"stream"}],"output":{"name":"stream"}}],[11,"coalesce","","Coalesce multiple event firings within the same transaction into a single event.",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"stream"}}],[11,"hold","","Hold an event in a signal.",1,{"inputs":[{"name":"self"},{"name":"a"}],"output":{"name":"signal"}}],[11,"events","","A blocking iterator over the stream.",1,{"inputs":[{"name":"self"}],"output":{"name":"events"}}],[11,"fold","","Scan a stream and accumulate its event firings in a signal.",1,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"signal"}}],[11,"filter_some","","Filter a stream of options.",1,{"inputs":[{"name":"self"}],"output":{"name":"stream"}}],[11,"switch","","Switch between streams.",1,{"inputs":[{"name":"self"}],"output":{"name":"stream"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"signal"}}],[11,"new","","Create a constant signal.",2,{"inputs":[{"name":"a"}],"output":{"name":"signal"}}],[11,"sample","","Sample the current value of the signal.",2,{"inputs":[{"name":"self"}],"output":{"name":"a"}}],[11,"cyclic","","Create a signal with a cyclic definition.",2,{"inputs":[{"name":"f"}],"output":{"name":"signal"}}],[11,"snapshot","","Combine the signal with a stream in a snapshot.",2,{"inputs":[{"name":"self"},{"name":"stream"},{"name":"f"}],"output":{"name":"stream"}}],[11,"map","","Map a signal using a function.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"signal"}}],[11,"switch","","Switch between signals.",2,{"inputs":[{"name":"self"}],"output":{"name":"signal"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"lift","","Lifting of n-ary functions.",null,null],[5,"lift0","carboxyl::lift","Lift a 0-ary function.",null,{"inputs":[{"name":"f"}],"output":{"name":"signal"}}],[5,"lift1","","Lift a unary function.",null,{"inputs":[{"name":"f"},{"name":"signal"}],"output":{"name":"signal"}}],[5,"lift2","","Lift a binary function.",null,{"inputs":[{"name":"f"},{"name":"signal"},{"name":"signal"}],"output":{"name":"signal"}}],[5,"lift3","","Lift a ternary function.",null,{"inputs":[{"name":"f"},{"name":"signal"},{"name":"signal"},{"name":"signal"}],"output":{"name":"signal"}}],[5,"lift4","","Lift a quarternary function.",null,{"inputs":[{"name":"f"},{"name":"signal"},{"name":"signal"},{"name":"signal"},{"name":"signal"}],"output":{"name":"signal"}}],[14,"lift","carboxyl","",null,null]],"paths":[[3,"Sink"],[3,"Stream"],[3,"Signal"]]};
searchIndex["lazy_static"] = {"doc":"A macro for declaring lazily evaluated statics.","items":[[14,"lazy_static","lazy_static","",null,null]],"paths":[]};
initSearch(searchIndex);
